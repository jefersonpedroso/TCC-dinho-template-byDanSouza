\chapter{Códigos Elaborados}
\section{Função para o cálculo da Taxa de Erro - bitError.m}
\begin{lstlisting}
% Function to calculate error tax in two text arquives
% Parameters:   bitErrorTax = bitError();
%               no input parameters

function bitErrorTax = bitError()
    %% Open the files
    % Read input file
    file = fopen('entrada.txt', 'r');
    input=fread(file);
    fclose(file);
    % Read output file
    file   = fopen('saida.txt', 'r');
    output=fread(file);
    fclose(file);

    %% Sweeping to find error
    errorBit = 0;
    for i=1:length(input)
        if input(i) ~= output(i)
            errorBit = errorBit + 1;              
        end
    end

    %% Finding the Tax
    bitErrorTax = errorBit/length(input);
end
\end{lstlisting}

\section{Cálculo das Taxas de Erro - bitErrorTax\_ BFSK\_ 4FSK\_ BPSK.m}
\begin{lstlisting}
% SNRs = [1 5 20]
% BFSK, 4-FSK, BPSK

SNRs = [0.5 1 5 10 15 20];
bitErrorTax_bfsk = zeros(0,length(SNRs));
bitErrorTax_4fsk = zeros(0,length(SNRs));
bitErrorTax_bpsk = zeros(0,length(SNRs));
for i=1:length(SNRs)
    trans_bfsk(SNRs(i));
    bitErrorTax_bfsk(i) = bitError();
end

for i=1:length(SNRs)
    trans_4fsk(SNRs(i));
    bitErrorTax_4fsk(i) = bitError();
end

for i=1:length(SNRs)    
    trans_bpsk(SNRs(i));
    bitErrorTax_bpsk(i) = bitError();
end

FID = fopen('bitErrorTax.txt','w');
fprintf(FID, 'bitErrorTax_bfsk = [');
for i=1:length(bitErrorTax_bfsk)
    fprintf(FID, '%d ',bitErrorTax_bfsk(i));
end
fprintf(FID, ']\n');

fprintf(FID, 'bitErrorTax_4fsk = [');
for i=1:length(bitErrorTax_4fsk)
    fprintf(FID, '%d ',bitErrorTax_4fsk(i));
end
fprintf(FID, ']\n');

fprintf(FID, 'bitErrorTax_bpsk = [');
for i=1:length(bitErrorTax_bpsk)
    fprintf(FID, '%d ',bitErrorTax_bpsk(i));
end
fprintf(FID, ']');
ST1 = fclose(FID);
\end{lstlisting}

\section{Codificação de linha - URZ}
\begin{lstlisting}
function [t,x,dt] = urz(bits, bitrate)
% URZ Encode bit string using unipolar RZ code.
%   [T, X] = URZ(BITS, BITRATE) encodes BITS array using unipolar RZ
%   code with given BITRATE. Outputs are time T and encoded signal
%   values X.

% Copyright (c) 2013 Yuriy Skalko <yuriy.skalko@gmail.com>

T = length(bits)/bitrate; % full time of bit sequence
n = 200;
N = n*length(bits);
dt = T/N;
t = 0:dt:T;
x = zeros(1,length(t)); % output signal

for i = 0:length(bits)-1
  if bits(i+1) == 1
    x(i*n+1:(i+0.5)*n) = 1;
    x((i+0.5)*n+1:(i+1)*n) = 0;
  else
    x(i*n+1:(i+1)*n) = 0;
  end
end
\end{lstlisting}

\section{Codificação de linha - UNRZ}
\begin{lstlisting}
function [t,x,dt] = unrz(bits, bitrate)
% UNRZ Encode bit string using unipolar NRZ code.
%   [T, X] = UNRZ(BITS, BITRATE) encodes BITS array using unipolar NRZ
%   code with given BITRATE. Outputs are time T and encoded signal
%   values X.

% Copyright (c) 2013 Yuriy Skalko <yuriy.skalko@gmail.com>

T = length(bits)/bitrate; % full time of bit sequence
n = 200;
N = n*length(bits);
dt = T/N;
t = 0:dt:T;
x = zeros(1,length(t)); % output signal

for i = 0:length(bits)-1
  if bits(i+1) == 1
    x(i*n+1:(i+1)*n) = 1;
  else
    x(i*n+1:(i+1)*n) = 0;
  end
end
\end{lstlisting}

\section{Codificação de linha - PRZ}
\begin{lstlisting}
function [t,x,dt] = prz(bits, bitrate)
% PRZ Encode bit string using polar RZ code.
%   [T, X] = PRZ(BITS, BITRATE) encodes BITS array using polar RZ
%   code with given BITRATE. Outputs are time T and encoded signal
%   values X.

% Copyright (c) 2013 Yuriy Skalko <yuriy.skalko@gmail.com>

T = length(bits)/bitrate; % full time of bit sequence
n = 200;
N = n*length(bits);
dt = T/N;
t = 0:dt:T;
x = zeros(1,length(t)); % output signal

for i = 0:length(bits)-1
  if bits(i+1) == 1
    x(i*n+1:(i+0.5)*n) = 1;
    x((i+0.5)*n+1:(i+1)*n) = 0;
  else
    x(i*n+1:(i+0.5)*n) = -1;
    x((i+0.5)*n+1:(i+1)*n) = 0;
  end
end
\end{lstlisting}

\section{Codificação de linha - Manchester}
\begin{lstlisting}
function [t,x,dt] = manchester(bits, bitrate)
% MANCHESTER Encode bit string using Manchester code.
%   [T, X] = MANCHESTER(BITS, BITRATE) encodes BITS array using Manchester
%   code with given BITRATE. Outputs are time T and encoded signal
%   values X.

% Copyright (c) 2013 Yuriy Skalko <yuriy.skalko@gmail.com>

T = length(bits)/bitrate; % full time of bit sequence
n = 200;
N = n*length(bits);
dt = T/N;
t = 0:dt:T;
x = zeros(1,length(t)); % output signal

for i = 0:length(bits)-1
  if bits(i+1) == 1
    x(i*n+1:(i+0.5)*n) = 1;
    x((i+0.5)*n+1:(i+1)*n) = -1;
  else
    x(i*n+1:(i+0.5)*n) = -1;
    x((i+0.5)*n+1:(i+1)*n) = 1;
  end
end
\end{lstlisting}

\section{Codificação de linha - Gráficos}
\begin{lstlisting}
% Demo of using different line codings
bits = [1 0 1 1 1 1 1 1 0 1 0 0 1 1 0 1 0 1 0 0];
bitrate = 1; % bits per second

%%UNRZ --------------------------------------
figure(1);
[t,s,dt] = unrz(bits,bitrate);
plot(t,s,'LineWidth',3);
axis([0 t(end) -0.1 1.1])
grid on;
title(['Unipolar NRZ: [' num2str(bits) ']']);

%Averange Value
avgVal=0;
for i=1:length(s)
    avgVal = avgVal + s(i);
end
averange_UNRZ = avgVal/length(s);

figure(2);
Fs = 1/dt;
pwelch(s,[],[],[],Fs);
title('Densidade Espectral UNRZ');

%%URZ ---------------------------------------
figure(3);
[t,s,dt] = urz(bits,bitrate);
plot(t,s,'LineWidth',3);
axis([0 t(end) -0.1 1.1])
grid on;
title(['Unipolar RZ: [' num2str(bits) ']']);

%Averange Value
avgVal=0;
for i=1:length(s)
    avgVal = avgVal + s(i);
end
averange_URZ = avgVal/length(s);

figure(4);
Fs = 1/dt;
pwelch(s,[],[],[],Fs);
title('Densidade Espectral URZ');

%%PRZ ---------------------------------------
figure(5);
[t,s,dt] = prz(bits,bitrate);
plot(t,s,'LineWidth',3);
axis([0 t(end) -1.1 1.1])
grid on;
title(['Polar RZ: [' num2str(bits) ']']);

%Averange Value
avgVal=0;
for i=1:length(s)
    avgVal = avgVal + s(i);
end
averange_PRZ = avgVal/length(s);

figure(6);
Fs = 1/dt;
pwelch(s,[],[],[],Fs);
title('Densidade Espectral PRZ');

%%Manchester --------------------------------
figure(7);
[t,s] = manchester(bits,bitrate);
plot(t,s,'LineWidth',3);
axis([0 t(end) -1.1 1.1])
grid on;
title(['Manchester: [' num2str(bits) ']']);

%Averange Value
avgVal=0;
for i=1:length(s)
    avgVal = avgVal + s(i);
end
averange_Manchester = avgVal/length(s);

figure(8);
Fs = 1/dt;
pwelch(s,[],[],[],Fs);
title('Densidade Espectral Manchester');
\end{lstlisting}
